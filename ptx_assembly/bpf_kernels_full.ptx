// =============================================================================
// bpf_kernels.ptx -- Bootstrap Particle Filter in raw PTX (COMPLETE)
// Target: SM_120 (Blackwell consumer / RTX 5080, 5090)
//
// Fully self-contained: PCG32 PRNG, ICDF normal generation (Acklam),
// Student-t sampling, OU state propagation, Silverman kernel smoothing.
// Zero cuRAND dependency.
//
// Kernels:
//   1.  bpf_init_rng          -- Seed per-particle PCG32 state
//   2.  bpf_init_particles    -- Draw from stationary N(mu, sigma_stat^2)
//   3.  bpf_propagate_weight  -- OU transition + obs log-likelihood (Gaussian/t)
//   4.  bpf_set_scalar        -- Initialize a device scalar
//   5.  bpf_reduce_max        -- Block-parallel max -> atomicMax
//   6.  bpf_reduce_sum        -- Block-parallel sum -> atomicAdd
//   7.  bpf_exp_sub           -- w[i] = exp(log_w[i] - max)
//   8.  bpf_scale_wh          -- Normalize weights, compute w*h
//   9.  bpf_compute_loglik    -- log(sum_w / N) + max_lw
//  10.  bpf_resample          -- Systematic resampling via binary search
//  11.  bpf_compute_var       -- Variance for Silverman bandwidth
//  12.  bpf_gen_noise         -- ICDF normal generation from PCG32
//  13.  bpf_silverman_jitter  -- Post-resample kernel smoothing
//
// PCG32 State: 2 x u64 per particle [state, inc] in flat array
// ICDF: Beasley-Springer-Moro rational approximation (~7 digit accuracy)
//
// Compile:  ptxas -arch=sm_120 -o bpf_kernels.cubin bpf_kernels.ptx
// =============================================================================

.version 8.8
.target sm_120
.address_size 64

.extern .shared .align 4 .b8 smem_raw[];


// -----------------------------------------------------------------------------
// MACRO-LIKE PATTERNS (inlined, PTX has no macros):
//
// PCG32_STEP: old=state; state=state*MULT+inc; output xorshift+rotate
// ICDF:       u in (0,1) -> z ~ N(0,1) via rational approx
// -----------------------------------------------------------------------------


// =============================================================================
// Kernel 1: bpf_init_rng
// =============================================================================

.visible .entry bpf_init_rng(
    .param .u64 param_rng,
    .param .u64 param_seed,
    .param .s32 param_n
)
{
    .reg .u32   %idx, %r_tid, %r_ctaid, %r_ntid, %r_n, %r_idx2;
    .reg .u64   %rd_rng, %rd_off, %rd_addr;
    .reg .u64   %rd_seed, %rd_state, %rd_inc, %rd_tmp, %rd_mul;
    .reg .pred  %p_bound;

    ld.param.u64    %rd_rng,  [param_rng];
    ld.param.u64    %rd_seed, [param_seed];
    ld.param.s32    %r_n,     [param_n];

    mov.u32         %r_tid,   %tid.x;
    mov.u32         %r_ctaid, %ctaid.x;
    mov.u32         %r_ntid,  %ntid.x;
    mad.lo.u32      %idx,     %r_ctaid, %r_ntid, %r_tid;

    setp.ge.u32     %p_bound, %idx, %r_n;
    @%p_bound bra   INIT_RNG_EXIT;

    // inc = (2*i + 1) | 1  (unique odd per particle)
    shl.b32         %r_idx2,  %idx, 1;
    add.u32         %r_idx2,  %r_idx2, 1;
    cvt.u64.u32     %rd_inc,  %r_idx2;
    or.b64          %rd_inc,  %rd_inc, 1;

    // state = seed * MULT + inc, then one step
    mov.u64         %rd_mul,  6364136223846793005;
    mul.lo.u64      %rd_state, %rd_seed, %rd_mul;
    add.u64         %rd_state, %rd_state, %rd_inc;
    mul.lo.u64      %rd_tmp,   %rd_state, %rd_mul;
    add.u64         %rd_state, %rd_tmp, %rd_inc;

    // Store [state, inc]
    mul.wide.u32    %rd_off,  %idx, 16;
    add.u64         %rd_addr, %rd_rng, %rd_off;
    st.global.u64   [%rd_addr + 0], %rd_state;
    st.global.u64   [%rd_addr + 8], %rd_inc;

INIT_RNG_EXIT:
    ret;
}


// =============================================================================
// Kernel 2: bpf_init_particles
//   h[i] = mu + std_stat * icdf(pcg32_float(rng[i]))
// =============================================================================

.visible .entry bpf_init_particles(
    .param .u64 param_h,
    .param .u64 param_rng,
    .param .f32 param_mu,
    .param .f32 param_std,
    .param .s32 param_n
)
{
    .reg .u32   %idx, %r_tid, %r_ctaid, %r_ntid, %r_n;
    .reg .u64   %rd_h, %rd_rng, %rd_off, %rd_rng_addr;
    .reg .u64   %rd_state, %rd_inc, %rd_old, %rd_mul, %rd_tmp;
    .reg .u32   %r_pcg, %r_xsh, %r_rot, %r_neg_rot, %r_lo, %r_hi;
    .reg .f32   %f_mu, %f_std, %f_u, %f_z, %f_h;
    .reg .f32   %f_q, %f_r, %f_num, %f_den, %f_abs_q;
    .reg .f32   %f_p, %f_log_p, %f_r_tail, %f_sqrt_tmp;
    .reg .pred  %p_bound, %p_central, %p_low_tail;

    ld.param.u64    %rd_h,   [param_h];
    ld.param.u64    %rd_rng, [param_rng];
    ld.param.f32    %f_mu,   [param_mu];
    ld.param.f32    %f_std,  [param_std];
    ld.param.s32    %r_n,    [param_n];

    mov.u32         %r_tid,   %tid.x;
    mov.u32         %r_ctaid, %ctaid.x;
    mov.u32         %r_ntid,  %ntid.x;
    mad.lo.u32      %idx,     %r_ctaid, %r_ntid, %r_tid;

    setp.ge.u32     %p_bound, %idx, %r_n;
    @%p_bound bra   INIT_P_EXIT;

    // Load RNG
    mul.wide.u32    %rd_off,      %idx, 16;
    add.u64         %rd_rng_addr, %rd_rng, %rd_off;
    ld.global.u64   %rd_state, [%rd_rng_addr + 0];
    ld.global.u64   %rd_inc,   [%rd_rng_addr + 8];

    // PCG32 step
    mov.u64         %rd_old, %rd_state;
    mov.u64         %rd_mul, 6364136223846793005;
    mul.lo.u64      %rd_tmp, %rd_state, %rd_mul;
    add.u64         %rd_state, %rd_tmp, %rd_inc;

    // PCG32 output
    shr.u64         %rd_tmp, %rd_old, 18;
    xor.b64         %rd_tmp, %rd_tmp, %rd_old;
    shr.u64         %rd_tmp, %rd_tmp, 27;
    cvt.u32.u64     %r_xsh, %rd_tmp;
    shr.u64         %rd_tmp, %rd_old, 59;
    cvt.u32.u64     %r_rot, %rd_tmp;
    shr.u32         %r_lo, %r_xsh, %r_rot;
    neg.s32         %r_neg_rot, %r_rot;
    and.b32         %r_neg_rot, %r_neg_rot, 31;
    shl.b32         %r_hi, %r_xsh, %r_neg_rot;
    or.b32          %r_pcg, %r_lo, %r_hi;

    // float in (0,1)
    shr.u32         %r_pcg, %r_pcg, 9;
    cvt.rn.f32.u32  %f_u, %r_pcg;
    mul.f32         %f_u, %f_u, 0f34000000;      // 1/8388608
    max.f32         %f_u, %f_u, 0f358637BD;      // 1e-6
    min.f32         %f_u, %f_u, 0f3F7FFBCE;      // 1-1e-6

    // ICDF (full Acklam)
    sub.f32         %f_q, %f_u, 0f3F000000;
    abs.f32         %f_abs_q, %f_q;
    setp.lt.f32     %p_central, %f_abs_q, 0f3EF39581;
    @!%p_central bra IP_TAIL;

    mul.f32         %f_r, %f_q, %f_q;
    fma.rn.f32      %f_num, %f_r, 0fC21EC98E, 0f435CF234;
    fma.rn.f32      %f_num, %f_r, %f_num, 0fC389F6D9;
    fma.rn.f32      %f_num, %f_r, %f_num, 0f430A5B96;
    fma.rn.f32      %f_num, %f_r, %f_num, 0fC1F55182;
    fma.rn.f32      %f_num, %f_r, %f_num, 0f40206C99;
    mul.f32         %f_num, %f_q, %f_num;
    fma.rn.f32      %f_den, %f_r, 0fC259E786, 0f432195F9;
    fma.rn.f32      %f_den, %f_r, %f_den, 0fC31BB2F0;
    fma.rn.f32      %f_den, %f_r, %f_den, 0f42859A46;
    fma.rn.f32      %f_den, %f_r, %f_den, 0fC1547DAC;
    fma.rn.f32      %f_den, %f_r, %f_den, 0f3F800000;
    div.approx.f32  %f_z, %f_num, %f_den;
    bra             IP_DONE;

IP_TAIL:
    setp.lt.f32     %p_low_tail, %f_u, 0f3F000000;
    mov.f32         %f_p, %f_u;
    @!%p_low_tail sub.f32 %f_p, 0f3F800000, %f_u;
    lg2.approx.f32  %f_log_p, %f_p;
    mul.f32         %f_log_p, %f_log_p, 0f3F317218;
    mul.f32         %f_r_tail, %f_log_p, 0fC0000000;
    sqrt.approx.f32 %f_r_tail, %f_r_tail;
    fma.rn.f32      %f_num, %f_r_tail, 0fBBFF186D, 0fBEA51126;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0fC019A606;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0fC0232ED1;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0f408BFD40;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0f403C0AE1;
    fma.rn.f32      %f_den, %f_r_tail, 0f3BFF16C3, 0f3EA51A69;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f401C7D14;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f4070483B;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f3F800000;
    div.approx.f32  %f_z, %f_num, %f_den;
    @!%p_low_tail neg.f32 %f_z, %f_z;

IP_DONE:
    fma.rn.f32      %f_h, %f_std, %f_z, %f_mu;

    mul.wide.u32    %rd_off, %idx, 4;
    .reg .u64 %rd_h_addr;
    add.u64         %rd_h_addr, %rd_h, %rd_off;
    st.global.f32   [%rd_h_addr], %f_h;
    st.global.u64   [%rd_rng_addr + 0], %rd_state;

INIT_P_EXIT:
    ret;
}


// =============================================================================
// Kernel 3: bpf_propagate_weight
//   Propagate (OU + optional Student-t noise) + compute observation log-weight
//   chi2 variates pre-generated on host (param_chi2 array)
//   Student-t obs constant precomputed on host (param_C_obs)
// =============================================================================

.visible .entry bpf_propagate_weight(
    .param .u64 param_h,
    .param .u64 param_log_w,
    .param .u64 param_rng,
    .param .u64 param_chi2,
    .param .f32 param_rho,
    .param .f32 param_sigma_z,
    .param .f32 param_mu,
    .param .f32 param_nu_state,
    .param .f32 param_nu_obs,
    .param .f32 param_C_obs,
    .param .f32 param_y_t,
    .param .s32 param_n,
    .param .s32 param_do_prop
)
{
    .reg .u32   %idx, %r_tid, %r_ctaid, %r_ntid, %r_n, %r_do_prop;
    .reg .u64   %rd_h, %rd_lw, %rd_rng, %rd_chi2, %rd_off, %rd_rng_addr;
    .reg .u64   %rd_state, %rd_inc, %rd_old, %rd_mul, %rd_tmp;
    .reg .u32   %r_pcg, %r_xsh, %r_rot, %r_neg_rot, %r_lo, %r_hi;
    .reg .f32   %f_rho, %f_sigma_z, %f_mu, %f_nu_state, %f_nu_obs, %f_yt, %f_C_obs;
    .reg .f32   %f_hi, %f_eps, %f_u, %f_z, %f_eta, %f_eta2, %f_log_w;
    .reg .f32   %f_q, %f_r, %f_num, %f_den, %f_abs_q;
    .reg .f32   %f_p, %f_log_p, %f_r_tail, %f_sqrt_tmp;
    .reg .pred  %p_bound, %p_do_prop, %p_central, %p_low_tail;
    .reg .pred  %p_t_state, %p_t_obs;

    ld.param.u64    %rd_h,       [param_h];
    ld.param.u64    %rd_lw,      [param_log_w];
    ld.param.u64    %rd_rng,     [param_rng];
    ld.param.u64    %rd_chi2,    [param_chi2];
    ld.param.f32    %f_rho,      [param_rho];
    ld.param.f32    %f_sigma_z,  [param_sigma_z];
    ld.param.f32    %f_mu,       [param_mu];
    ld.param.f32    %f_nu_state, [param_nu_state];
    ld.param.f32    %f_nu_obs,   [param_nu_obs];
    ld.param.f32    %f_C_obs,    [param_C_obs];
    ld.param.f32    %f_yt,       [param_y_t];
    ld.param.s32    %r_n,        [param_n];
    ld.param.s32    %r_do_prop,  [param_do_prop];

    mov.u32         %r_tid,   %tid.x;
    mov.u32         %r_ctaid, %ctaid.x;
    mov.u32         %r_ntid,  %ntid.x;
    mad.lo.u32      %idx,     %r_ctaid, %r_ntid, %r_tid;

    setp.ge.u32     %p_bound, %idx, %r_n;
    @%p_bound bra   PW_EXIT;

    // Load h[i]
    mul.wide.u32    %rd_off, %idx, 4;
    .reg .u64 %rd_h_addr, %rd_lw_addr;
    add.u64         %rd_h_addr,  %rd_h, %rd_off;
    add.u64         %rd_lw_addr, %rd_lw, %rd_off;
    ld.global.f32   %f_hi, [%rd_h_addr];

    // Load RNG
    mul.wide.u32    %rd_off, %idx, 16;
    add.u64         %rd_rng_addr, %rd_rng, %rd_off;
    ld.global.u64   %rd_state, [%rd_rng_addr + 0];
    ld.global.u64   %rd_inc,   [%rd_rng_addr + 8];
    mov.u64         %rd_mul, 6364136223846793005;

    setp.ne.s32     %p_do_prop, %r_do_prop, 0;
    @!%p_do_prop bra PW_WEIGHT;

    // === PROPAGATION ===

    // PCG32 step -> uniform -> ICDF -> z ~ N(0,1)
    mov.u64         %rd_old, %rd_state;
    mul.lo.u64      %rd_tmp, %rd_state, %rd_mul;
    add.u64         %rd_state, %rd_tmp, %rd_inc;
    shr.u64         %rd_tmp, %rd_old, 18;
    xor.b64         %rd_tmp, %rd_tmp, %rd_old;
    shr.u64         %rd_tmp, %rd_tmp, 27;
    cvt.u32.u64     %r_xsh, %rd_tmp;
    shr.u64         %rd_tmp, %rd_old, 59;
    cvt.u32.u64     %r_rot, %rd_tmp;
    shr.u32         %r_lo, %r_xsh, %r_rot;
    neg.s32         %r_neg_rot, %r_rot;
    and.b32         %r_neg_rot, %r_neg_rot, 31;
    shl.b32         %r_hi, %r_xsh, %r_neg_rot;
    or.b32          %r_pcg, %r_lo, %r_hi;
    shr.u32         %r_pcg, %r_pcg, 9;
    cvt.rn.f32.u32  %f_u, %r_pcg;
    mul.f32         %f_u, %f_u, 0f34000000;
    max.f32         %f_u, %f_u, 0f358637BD;
    min.f32         %f_u, %f_u, 0f3F7FFBCE;

    // ICDF (full Acklam)
    sub.f32         %f_q, %f_u, 0f3F000000;
    abs.f32         %f_abs_q, %f_q;
    setp.lt.f32     %p_central, %f_abs_q, 0f3EF39581;
    @!%p_central bra PW_TAIL;

    mul.f32         %f_r, %f_q, %f_q;
    fma.rn.f32      %f_num, %f_r, 0fC21EC98E, 0f435CF234;
    fma.rn.f32      %f_num, %f_r, %f_num, 0fC389F6D9;
    fma.rn.f32      %f_num, %f_r, %f_num, 0f430A5B96;
    fma.rn.f32      %f_num, %f_r, %f_num, 0fC1F55182;
    fma.rn.f32      %f_num, %f_r, %f_num, 0f40206C99;
    mul.f32         %f_num, %f_q, %f_num;
    fma.rn.f32      %f_den, %f_r, 0fC259E786, 0f432195F9;
    fma.rn.f32      %f_den, %f_r, %f_den, 0fC31BB2F0;
    fma.rn.f32      %f_den, %f_r, %f_den, 0f42859A46;
    fma.rn.f32      %f_den, %f_r, %f_den, 0fC1547DAC;
    fma.rn.f32      %f_den, %f_r, %f_den, 0f3F800000;
    div.approx.f32  %f_z, %f_num, %f_den;
    bra             PW_ICDF_OK;

PW_TAIL:
    setp.lt.f32     %p_low_tail, %f_u, 0f3F000000;
    mov.f32         %f_p, %f_u;
    @!%p_low_tail sub.f32 %f_p, 0f3F800000, %f_u;
    lg2.approx.f32  %f_log_p, %f_p;
    mul.f32         %f_log_p, %f_log_p, 0f3F317218;
    mul.f32         %f_r_tail, %f_log_p, 0fC0000000;
    sqrt.approx.f32 %f_r_tail, %f_r_tail;
    fma.rn.f32      %f_num, %f_r_tail, 0fBBFF186D, 0fBEA51126;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0fC019A606;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0fC0232ED1;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0f408BFD40;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0f403C0AE1;
    fma.rn.f32      %f_den, %f_r_tail, 0f3BFF16C3, 0f3EA51A69;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f401C7D14;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f4070483B;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f3F800000;
    div.approx.f32  %f_z, %f_num, %f_den;
    @!%p_low_tail neg.f32 %f_z, %f_z;

PW_ICDF_OK:
    mov.f32         %f_eps, %f_z;

    // Student-t state noise: eps = z * sqrt(nu / chi2)
    // chi2 is pre-generated on host and loaded from param_chi2 array
    setp.gt.f32     %p_t_state, %f_nu_state, 0f00000000;
    @!%p_t_state bra PW_TRANS;

    .reg .f32 %f_chi2, %f_scale;
    mul.wide.u32    %rd_off, %idx, 4;
    .reg .u64 %rd_chi2_addr;
    add.u64         %rd_chi2_addr, %rd_chi2, %rd_off;
    ld.global.f32   %f_chi2, [%rd_chi2_addr];
    div.approx.f32  %f_scale, %f_chi2, %f_nu_state;
    rsqrt.approx.f32 %f_scale, %f_scale;
    mul.f32         %f_eps, %f_z, %f_scale;

PW_TRANS:
    // h = mu + rho*(h-mu) + sigma_z*eps
    .reg .f32 %f_dev;
    sub.f32         %f_dev, %f_hi, %f_mu;
    mul.f32         %f_dev, %f_rho, %f_dev;
    add.f32         %f_hi, %f_mu, %f_dev;
    fma.rn.f32      %f_hi, %f_sigma_z, %f_eps, %f_hi;
    st.global.f32   [%rd_h_addr], %f_hi;

PW_WEIGHT:
    // === OBSERVATION WEIGHT ===
    .reg .f32 %f_neg_half, %f_exp_arg;
    mov.f32         %f_neg_half, 0fBF000000;
    mul.f32         %f_exp_arg, %f_hi, %f_neg_half;
    mul.f32         %f_exp_arg, %f_exp_arg, 0f3FB8AA3B;   // *log2(e)
    ex2.approx.f32  %f_exp_arg, %f_exp_arg;
    mul.f32         %f_eta, %f_yt, %f_exp_arg;

    setp.gt.f32     %p_t_obs, %f_nu_obs, 0f00000000;
    @%p_t_obs bra   PW_T_OBS;

    // Gaussian obs: log_w = -0.5*log(2pi) - 0.5*eta^2 - 0.5*h
    mul.f32         %f_eta2, %f_eta, %f_eta;
    mov.f32         %f_log_w, 0fBF6B3F8E;     // -0.5*log(2pi)
    fma.rn.f32      %f_log_w, %f_neg_half, %f_eta2, %f_log_w;
    fma.rn.f32      %f_log_w, %f_neg_half, %f_hi, %f_log_w;
    bra             PW_STORE;

PW_T_OBS:
    // Student-t obs: C_obs precomputed on host
    // log_w = C_obs - (nu+1)/2 * log(1 + eta^2/nu) - 0.5*h
    .reg .f32 %f_nu_p1h, %f_t_arg, %f_log_t;

    add.f32         %f_nu_p1h, %f_nu_obs, 0f3F800000;
    mul.f32         %f_nu_p1h, %f_nu_p1h, 0f3F000000;    // (nu+1)/2

    mul.f32         %f_eta2, %f_eta, %f_eta;
    div.approx.f32  %f_t_arg, %f_eta2, %f_nu_obs;
    add.f32         %f_t_arg, %f_t_arg, 0f3F800000;       // 1 + eta^2/nu
    lg2.approx.f32  %f_log_t, %f_t_arg;
    mul.f32         %f_log_t, %f_log_t, 0f3F317218;       // *ln2
    .reg .f32 %f_neg_nph;
    neg.f32         %f_neg_nph, %f_nu_p1h;
    mul.f32         %f_log_t, %f_neg_nph, %f_log_t;       // -(nu+1)/2 * log(...)

    // Assemble: C_obs + log_t - 0.5*h
    add.f32         %f_log_w, %f_C_obs, %f_log_t;
    fma.rn.f32      %f_log_w, %f_neg_half, %f_hi, %f_log_w;

PW_STORE:
    st.global.f32   [%rd_lw_addr], %f_log_w;
    st.global.u64   [%rd_rng_addr + 0], %rd_state;

PW_EXIT:
    ret;
}


// =============================================================================
// Kernel 4: bpf_set_scalar    *scalar = val
// =============================================================================

.visible .entry bpf_set_scalar(
    .param .u64 param_ptr,
    .param .f32 param_val
)
{
    .reg .u64 %rd; .reg .f32 %f;
    ld.param.u64 %rd, [param_ptr];
    ld.param.f32 %f,  [param_val];
    st.global.f32 [%rd], %f;
    ret;
}


// =============================================================================
// Kernel 5: bpf_reduce_max   Block->atomicMax(CAS)
// =============================================================================

.visible .entry bpf_reduce_max(
    .param .u64 param_in,
    .param .u64 param_out,
    .param .s32 param_n
)
{
    .reg .u32   %r_tid, %idx, %r_ctaid, %r_n, %r_s, %r_partner, %r_ntid;
    .reg .u64   %rd_in, %rd_out, %rd_off;
    .reg .u64   %rd_smem_base, %rd_smem, %rd_smem_partner;
    .reg .f32   %f_val, %f_other, %f_max;
    .reg .pred  %p_bound, %p_active, %p_tid0, %p_loop;

    ld.param.u64 %rd_in,  [param_in];
    ld.param.u64 %rd_out, [param_out];
    ld.param.s32 %r_n,    [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    mov.u64 %rd_smem_base, smem_raw;

    mov.f32 %f_val, 0fF49A4F80;
    setp.lt.u32 %p_bound, %idx, %r_n;
    @!%p_bound bra RM_LD;
    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_s1;
    add.u64 %rd_s1, %rd_in, %rd_off;
    ld.global.f32 %f_val, [%rd_s1];
RM_LD:
    .reg .u64 %rd_to;
    mul.wide.u32 %rd_to, %r_tid, 4;
    add.u64 %rd_smem, %rd_smem_base, %rd_to;
    st.shared.f32 [%rd_smem], %f_val;
    bar.sync 0;

    shr.u32 %r_s, %r_ntid, 1;
RM_LP:
    setp.eq.u32 %p_loop, %r_s, 0;
    @%p_loop bra RM_DN;
    setp.lt.u32 %p_active, %r_tid, %r_s;
    @!%p_active bra RM_SK;
    add.u32 %r_partner, %r_tid, %r_s;
    mul.wide.u32 %rd_off, %r_partner, 4;
    add.u64 %rd_smem_partner, %rd_smem_base, %rd_off;
    ld.shared.f32 %f_other, [%rd_smem_partner];
    ld.shared.f32 %f_val,   [%rd_smem];
    max.f32 %f_max, %f_val, %f_other;
    st.shared.f32 [%rd_smem], %f_max;
RM_SK:
    bar.sync 0;
    shr.u32 %r_s, %r_s, 1;
    bra RM_LP;
RM_DN:
    setp.eq.u32 %p_tid0, %r_tid, 0;
    @!%p_tid0 bra RM_EX;
    ld.shared.f32 %f_val, [%rd_smem];
    .reg .u32 %r_old, %r_assumed, %r_new;
    .reg .f32 %f_old, %f_cmp;
    .reg .pred %p_cas;
    ld.global.u32 %r_old, [%rd_out];
RM_CAS:
    mov.u32 %r_assumed, %r_old;
    mov.b32 %f_old, %r_assumed;
    max.f32 %f_cmp, %f_val, %f_old;
    mov.b32 %r_new, %f_cmp;
    atom.global.cas.b32 %r_old, [%rd_out], %r_assumed, %r_new;
    setp.ne.u32 %p_cas, %r_old, %r_assumed;
    @%p_cas bra RM_CAS;
RM_EX:
    ret;
}


// =============================================================================
// Kernel 6: bpf_reduce_sum   Block->atomicAdd.f32
// =============================================================================

.visible .entry bpf_reduce_sum(
    .param .u64 param_in,
    .param .u64 param_out,
    .param .s32 param_n
)
{
    .reg .u32   %r_tid, %idx, %r_ctaid, %r_n, %r_s, %r_partner, %r_ntid;
    .reg .u64   %rd_in, %rd_out, %rd_off;
    .reg .u64   %rd_smem_base, %rd_smem, %rd_smem_partner;
    .reg .f32   %f_val, %f_other, %f_sum;
    .reg .pred  %p_bound, %p_active, %p_tid0, %p_loop;

    ld.param.u64 %rd_in,  [param_in];
    ld.param.u64 %rd_out, [param_out];
    ld.param.s32 %r_n,    [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    mov.u64 %rd_smem_base, smem_raw;

    mov.f32 %f_val, 0f00000000;
    setp.lt.u32 %p_bound, %idx, %r_n;
    @!%p_bound bra RS_LD;
    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_s1;
    add.u64 %rd_s1, %rd_in, %rd_off;
    ld.global.f32 %f_val, [%rd_s1];
RS_LD:
    .reg .u64 %rd_to;
    mul.wide.u32 %rd_to, %r_tid, 4;
    add.u64 %rd_smem, %rd_smem_base, %rd_to;
    st.shared.f32 [%rd_smem], %f_val;
    bar.sync 0;

    shr.u32 %r_s, %r_ntid, 1;
RS_LP:
    setp.eq.u32 %p_loop, %r_s, 0;
    @%p_loop bra RS_DN;
    setp.lt.u32 %p_active, %r_tid, %r_s;
    @!%p_active bra RS_SK;
    add.u32 %r_partner, %r_tid, %r_s;
    mul.wide.u32 %rd_off, %r_partner, 4;
    add.u64 %rd_smem_partner, %rd_smem_base, %rd_off;
    ld.shared.f32 %f_other, [%rd_smem_partner];
    ld.shared.f32 %f_val,   [%rd_smem];
    add.f32 %f_sum, %f_val, %f_other;
    st.shared.f32 [%rd_smem], %f_sum;
RS_SK:
    bar.sync 0;
    shr.u32 %r_s, %r_s, 1;
    bra RS_LP;
RS_DN:
    setp.eq.u32 %p_tid0, %r_tid, 0;
    @!%p_tid0 bra RS_EX;
    ld.shared.f32 %f_val, [%rd_smem];
    atom.global.add.f32 %f_val, [%rd_out], %f_val;
RS_EX:
    ret;
}


// =============================================================================
// Kernel 7: bpf_exp_sub   w[i] = exp(log_w[i] - *d_max)
// =============================================================================

.visible .entry bpf_exp_sub(
    .param .u64 param_w,
    .param .u64 param_log_w,
    .param .u64 param_d_max,
    .param .s32 param_n
)
{
    .reg .u32 %idx, %r_tid, %r_ctaid, %r_ntid, %r_n;
    .reg .u64 %rd_w, %rd_lw, %rd_max, %rd_off;
    .reg .f32 %f_lw, %f_max, %f_diff, %f_exp;
    .reg .pred %p_bound;

    ld.param.u64 %rd_w,   [param_w];
    ld.param.u64 %rd_lw,  [param_log_w];
    ld.param.u64 %rd_max, [param_d_max];
    ld.param.s32 %r_n,    [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    setp.ge.u32 %p_bound, %idx, %r_n;
    @%p_bound bra ES_EX;
    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_s, %rd_d;
    add.u64 %rd_s, %rd_lw, %rd_off;
    ld.global.f32 %f_lw, [%rd_s];
    ld.global.f32 %f_max, [%rd_max];
    sub.f32 %f_diff, %f_lw, %f_max;
    mul.f32 %f_diff, %f_diff, 0f3FB8AA3B;
    ex2.approx.f32 %f_exp, %f_diff;
    add.u64 %rd_d, %rd_w, %rd_off;
    st.global.f32 [%rd_d], %f_exp;
ES_EX:
    ret;
}


// =============================================================================
// Kernel 8: bpf_scale_wh   w[i]/=sum, wh[i]=w[i]*h[i]
// =============================================================================

.visible .entry bpf_scale_wh(
    .param .u64 param_w,
    .param .u64 param_wh,
    .param .u64 param_h,
    .param .u64 param_d_sum,
    .param .s32 param_n
)
{
    .reg .u32 %idx, %r_tid, %r_ctaid, %r_ntid, %r_n;
    .reg .u64 %rd_w, %rd_wh, %rd_h, %rd_sum, %rd_off;
    .reg .f32 %f_w, %f_h, %f_sum, %f_inv, %f_wh;
    .reg .pred %p_bound;

    ld.param.u64 %rd_w,   [param_w];
    ld.param.u64 %rd_wh,  [param_wh];
    ld.param.u64 %rd_h,   [param_h];
    ld.param.u64 %rd_sum, [param_d_sum];
    ld.param.s32 %r_n,    [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    setp.ge.u32 %p_bound, %idx, %r_n;
    @%p_bound bra SW_EX;
    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_sw, %rd_sh;
    add.u64 %rd_sw, %rd_w, %rd_off;
    add.u64 %rd_sh, %rd_h, %rd_off;
    ld.global.f32 %f_w,   [%rd_sw];
    ld.global.f32 %f_h,   [%rd_sh];
    ld.global.f32 %f_sum, [%rd_sum];
    rcp.approx.f32 %f_inv, %f_sum;
    mul.f32 %f_w, %f_w, %f_inv;
    st.global.f32 [%rd_sw], %f_w;
    mul.f32 %f_wh, %f_w, %f_h;
    .reg .u64 %rd_dwh;
    add.u64 %rd_dwh, %rd_wh, %rd_off;
    st.global.f32 [%rd_dwh], %f_wh;
SW_EX:
    ret;
}


// =============================================================================
// Kernel 9: bpf_compute_loglik
// =============================================================================

.visible .entry bpf_compute_loglik(
    .param .u64 param_scalars,
    .param .s32 param_n
)
{
    .reg .u64 %rd_s; .reg .s32 %r_n;
    .reg .f32 %f_mlw, %f_sw, %f_n, %f_r, %f_l2, %f_ll, %f_fl;
    ld.param.u64 %rd_s, [param_scalars];
    ld.param.s32 %r_n,  [param_n];
    ld.global.f32 %f_mlw, [%rd_s + 0];
    ld.global.f32 %f_sw,  [%rd_s + 4];
    cvt.rn.f32.s32 %f_n, %r_n;
    div.approx.f32 %f_r, %f_sw, %f_n;
    mov.f32 %f_fl, 0f0D6BF94E;
    max.f32 %f_r, %f_r, %f_fl;
    lg2.approx.f32 %f_l2, %f_r;
    mul.f32 %f_ll, %f_l2, 0f3F317218;
    add.f32 %f_ll, %f_ll, %f_mlw;
    st.global.f32 [%rd_s + 12], %f_ll;
    ret;
}


// =============================================================================
// Kernel 10: bpf_resample   Systematic resampling
// =============================================================================

.visible .entry bpf_resample(
    .param .u64 param_h_out,
    .param .u64 param_h_in,
    .param .u64 param_cdf,
    .param .f32 param_u_base,
    .param .s32 param_n
)
{
    .reg .u32 %idx, %r_tid, %r_ctaid, %r_ntid, %r_n;
    .reg .u64 %rd_out, %rd_in, %rd_cdf, %rd_off;
    .reg .f32 %f_u, %f_target, %f_idx_f, %f_n_f, %f_one, %f_cdf_mid;
    .reg .s32 %r_lo, %r_hi, %r_mid;
    .reg .pred %p_bound, %p_ge1, %p_loop, %p_lt;

    ld.param.u64 %rd_out, [param_h_out];
    ld.param.u64 %rd_in,  [param_h_in];
    ld.param.u64 %rd_cdf, [param_cdf];
    ld.param.f32 %f_u,    [param_u_base];
    ld.param.s32 %r_n,    [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    setp.ge.u32 %p_bound, %idx, %r_n;
    @%p_bound bra RE_EX;

    cvt.rn.f32.u32 %f_idx_f, %idx;
    cvt.rn.f32.s32 %f_n_f, %r_n;
    div.approx.f32 %f_target, %f_idx_f, %f_n_f;
    add.f32 %f_target, %f_target, %f_u;
    mov.f32 %f_one, 0f3F800000;
    setp.ge.f32 %p_ge1, %f_target, %f_one;
    @%p_ge1 sub.f32 %f_target, %f_target, %f_one;

    mov.s32 %r_lo, 0;
    sub.s32 %r_hi, %r_n, 1;
BS_LP:
    setp.ge.s32 %p_loop, %r_lo, %r_hi;
    @%p_loop bra BS_DN;
    add.s32 %r_mid, %r_lo, %r_hi;
    shr.s32 %r_mid, %r_mid, 1;
    .reg .u64 %rd_cm;
    mul.wide.s32 %rd_off, %r_mid, 4;
    add.u64 %rd_cm, %rd_cdf, %rd_off;
    ld.global.f32 %f_cdf_mid, [%rd_cm];
    setp.lt.f32 %p_lt, %f_cdf_mid, %f_target;
    @%p_lt  add.s32 %r_lo, %r_mid, 1;
    @!%p_lt mov.s32 %r_hi, %r_mid;
    bra BS_LP;
BS_DN:
    .reg .u64 %rd_src, %rd_dst;
    .reg .f32 %f_h;
    mul.wide.s32 %rd_off, %r_lo, 4;
    add.u64 %rd_src, %rd_in, %rd_off;
    ld.global.f32 %f_h, [%rd_src];
    mul.wide.u32 %rd_off, %idx, 4;
    add.u64 %rd_dst, %rd_out, %rd_off;
    st.global.f32 [%rd_dst], %f_h;
RE_EX:
    ret;
}


// =============================================================================
// Kernel 11: bpf_compute_var   sum((h[i]-mean)^2) -> atomicAdd to *d_var
// =============================================================================

.visible .entry bpf_compute_var(
    .param .u64 param_h,
    .param .u64 param_d_var,
    .param .f32 param_h_mean,
    .param .s32 param_n
)
{
    .reg .u32 %idx, %r_tid, %r_ctaid, %r_ntid, %r_n, %r_s, %r_partner;
    .reg .u64 %rd_h, %rd_var, %rd_off;
    .reg .u64 %rd_smem_base, %rd_smem, %rd_smem_partner;
    .reg .f32 %f_h, %f_mean, %f_dev, %f_d2, %f_other, %f_val;
    .reg .pred %p_bound, %p_active, %p_tid0, %p_loop;

    ld.param.u64 %rd_h,    [param_h];
    ld.param.u64 %rd_var,  [param_d_var];
    ld.param.f32 %f_mean,  [param_h_mean];
    ld.param.s32 %r_n,     [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    mov.u64 %rd_smem_base, smem_raw;

    mov.f32 %f_d2, 0f00000000;
    setp.lt.u32 %p_bound, %idx, %r_n;
    @!%p_bound bra CV_SM;
    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_ha;
    add.u64 %rd_ha, %rd_h, %rd_off;
    ld.global.f32 %f_h, [%rd_ha];
    sub.f32 %f_dev, %f_h, %f_mean;
    mul.f32 %f_d2, %f_dev, %f_dev;
CV_SM:
    .reg .u64 %rd_to;
    mul.wide.u32 %rd_to, %r_tid, 4;
    add.u64 %rd_smem, %rd_smem_base, %rd_to;
    st.shared.f32 [%rd_smem], %f_d2;
    bar.sync 0;

    shr.u32 %r_s, %r_ntid, 1;
CV_LP:
    setp.eq.u32 %p_loop, %r_s, 0;
    @%p_loop bra CV_DN;
    setp.lt.u32 %p_active, %r_tid, %r_s;
    @!%p_active bra CV_SK;
    add.u32 %r_partner, %r_tid, %r_s;
    mul.wide.u32 %rd_off, %r_partner, 4;
    add.u64 %rd_smem_partner, %rd_smem_base, %rd_off;
    ld.shared.f32 %f_other, [%rd_smem_partner];
    ld.shared.f32 %f_val,   [%rd_smem];
    add.f32 %f_val, %f_val, %f_other;
    st.shared.f32 [%rd_smem], %f_val;
CV_SK:
    bar.sync 0;
    shr.u32 %r_s, %r_s, 1;
    bra CV_LP;
CV_DN:
    setp.eq.u32 %p_tid0, %r_tid, 0;
    @!%p_tid0 bra CV_EX;
    ld.shared.f32 %f_val, [%rd_smem];
    atom.global.add.f32 %f_val, [%rd_var], %f_val;
CV_EX:
    ret;
}


// =============================================================================
// Kernel 12: bpf_gen_noise   noise[i] = icdf(pcg32_float(rng[i]))
// =============================================================================

.visible .entry bpf_gen_noise(
    .param .u64 param_noise,
    .param .u64 param_rng,
    .param .s32 param_n
)
{
    .reg .u32 %idx, %r_tid, %r_ctaid, %r_ntid, %r_n;
    .reg .u64 %rd_noise, %rd_rng, %rd_off, %rd_rng_addr;
    .reg .u64 %rd_state, %rd_inc, %rd_old, %rd_mul, %rd_tmp;
    .reg .u32 %r_pcg, %r_xsh, %r_rot, %r_neg_rot, %r_lo, %r_hi;
    .reg .f32 %f_u, %f_z, %f_q, %f_r, %f_num, %f_den, %f_abs_q;
    .reg .f32 %f_p, %f_log_p, %f_r_tail, %f_sqrt_tmp;
    .reg .pred %p_bound, %p_central, %p_low_tail;

    ld.param.u64 %rd_noise, [param_noise];
    ld.param.u64 %rd_rng,   [param_rng];
    ld.param.s32 %r_n,      [param_n];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    setp.ge.u32 %p_bound, %idx, %r_n;
    @%p_bound bra GN_EX;

    // Load RNG
    mul.wide.u32 %rd_off, %idx, 16;
    add.u64 %rd_rng_addr, %rd_rng, %rd_off;
    ld.global.u64 %rd_state, [%rd_rng_addr + 0];
    ld.global.u64 %rd_inc,   [%rd_rng_addr + 8];
    mov.u64 %rd_mul, 6364136223846793005;

    // PCG32 step
    mov.u64 %rd_old, %rd_state;
    mul.lo.u64 %rd_tmp, %rd_state, %rd_mul;
    add.u64 %rd_state, %rd_tmp, %rd_inc;
    shr.u64 %rd_tmp, %rd_old, 18;
    xor.b64 %rd_tmp, %rd_tmp, %rd_old;
    shr.u64 %rd_tmp, %rd_tmp, 27;
    cvt.u32.u64 %r_xsh, %rd_tmp;
    shr.u64 %rd_tmp, %rd_old, 59;
    cvt.u32.u64 %r_rot, %rd_tmp;
    shr.u32 %r_lo, %r_xsh, %r_rot;
    neg.s32 %r_neg_rot, %r_rot;
    and.b32 %r_neg_rot, %r_neg_rot, 31;
    shl.b32 %r_hi, %r_xsh, %r_neg_rot;
    or.b32  %r_pcg, %r_lo, %r_hi;
    shr.u32 %r_pcg, %r_pcg, 9;
    cvt.rn.f32.u32 %f_u, %r_pcg;
    mul.f32 %f_u, %f_u, 0f34000000;
    max.f32 %f_u, %f_u, 0f358637BD;
    min.f32 %f_u, %f_u, 0f3F7FFBCE;

    // ICDF (full Acklam)
    sub.f32         %f_q, %f_u, 0f3F000000;
    abs.f32         %f_abs_q, %f_q;
    setp.lt.f32     %p_central, %f_abs_q, 0f3EF39581;
    @!%p_central bra GN_TL;

    mul.f32         %f_r, %f_q, %f_q;
    fma.rn.f32      %f_num, %f_r, 0fC21EC98E, 0f435CF234;
    fma.rn.f32      %f_num, %f_r, %f_num, 0fC389F6D9;
    fma.rn.f32      %f_num, %f_r, %f_num, 0f430A5B96;
    fma.rn.f32      %f_num, %f_r, %f_num, 0fC1F55182;
    fma.rn.f32      %f_num, %f_r, %f_num, 0f40206C99;
    mul.f32         %f_num, %f_q, %f_num;
    fma.rn.f32      %f_den, %f_r, 0fC259E786, 0f432195F9;
    fma.rn.f32      %f_den, %f_r, %f_den, 0fC31BB2F0;
    fma.rn.f32      %f_den, %f_r, %f_den, 0f42859A46;
    fma.rn.f32      %f_den, %f_r, %f_den, 0fC1547DAC;
    fma.rn.f32      %f_den, %f_r, %f_den, 0f3F800000;
    div.approx.f32  %f_z, %f_num, %f_den;
    bra             GN_OK;

GN_TL:
    setp.lt.f32     %p_low_tail, %f_u, 0f3F000000;
    mov.f32         %f_p, %f_u;
    @!%p_low_tail sub.f32 %f_p, 0f3F800000, %f_u;
    lg2.approx.f32  %f_log_p, %f_p;
    mul.f32         %f_log_p, %f_log_p, 0f3F317218;
    mul.f32         %f_r_tail, %f_log_p, 0fC0000000;
    sqrt.approx.f32 %f_r_tail, %f_r_tail;
    fma.rn.f32      %f_num, %f_r_tail, 0fBBFF186D, 0fBEA51126;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0fC019A606;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0fC0232ED1;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0f408BFD40;
    fma.rn.f32      %f_num, %f_r_tail, %f_num, 0f403C0AE1;
    fma.rn.f32      %f_den, %f_r_tail, 0f3BFF16C3, 0f3EA51A69;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f401C7D14;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f4070483B;
    fma.rn.f32      %f_den, %f_r_tail, %f_den, 0f3F800000;
    div.approx.f32  %f_z, %f_num, %f_den;
    @!%p_low_tail neg.f32 %f_z, %f_z;

GN_OK:
    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_na;
    add.u64 %rd_na, %rd_noise, %rd_off;
    st.global.f32 [%rd_na], %f_z;
    st.global.u64 [%rd_rng_addr + 0], %rd_state;
GN_EX:
    ret;
}


// =============================================================================
// Kernel 13: bpf_silverman_jitter   h[i] += bw*noise[i], clamp [mu-8,mu+8]
// =============================================================================

.visible .entry bpf_silverman_jitter(
    .param .u64 param_h,
    .param .u64 param_noise,
    .param .f32 param_bw,
    .param .s32 param_n,
    .param .f32 param_mu
)
{
    .reg .u32 %idx, %r_tid, %r_ctaid, %r_ntid, %r_n;
    .reg .u64 %rd_h, %rd_noise, %rd_off;
    .reg .f32 %f_h, %f_noise, %f_bw, %f_mu, %f_lo, %f_hi;
    .reg .pred %p_bound;

    ld.param.u64 %rd_h,     [param_h];
    ld.param.u64 %rd_noise, [param_noise];
    ld.param.f32 %f_bw,     [param_bw];
    ld.param.s32 %r_n,      [param_n];
    ld.param.f32 %f_mu,     [param_mu];
    mov.u32 %r_tid,   %tid.x;
    mov.u32 %r_ctaid, %ctaid.x;
    mov.u32 %r_ntid,  %ntid.x;
    mad.lo.u32 %idx, %r_ctaid, %r_ntid, %r_tid;
    setp.ge.u32 %p_bound, %idx, %r_n;
    @%p_bound bra SJ_EX;

    mul.wide.u32 %rd_off, %idx, 4;
    .reg .u64 %rd_ha, %rd_na;
    add.u64 %rd_ha, %rd_h, %rd_off;
    add.u64 %rd_na, %rd_noise, %rd_off;
    ld.global.f32 %f_h,     [%rd_ha];
    ld.global.f32 %f_noise, [%rd_na];
    fma.rn.f32 %f_h, %f_bw, %f_noise, %f_h;
    sub.f32 %f_lo, %f_mu, 0f41000000;
    add.f32 %f_hi, %f_mu, 0f41000000;
    max.f32 %f_h, %f_h, %f_lo;
    min.f32 %f_h, %f_h, %f_hi;
    st.global.f32 [%rd_ha], %f_h;
SJ_EX:
    ret;
}
